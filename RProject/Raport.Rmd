---
title: "Analiza danych krystalograficznych w R pochodzących z bazy Protein Data Bank (PDB)"
author: "Michał Hejduk"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Wstęp

Na początku pliku powinna znajdować się automatycznie wypełniona data generacji dokumentu oraz spis treści pozwalający przejść do najważniejszych sekcji. Ponadto raport powinien zaczynać się od rozdziału podsumowującego całą analizę, streszczającego najważniejsze spostrzeżenia analityka.

#1. Wykorzystane biblioteki
```{r bilbioteki, warning=FALSE, message=FALSE, hide = TRUE}
library(dplyr)
library(tibble)
library(tidyr) #transforming data
library(ggplot2)
library(kableExtra) #nicer tables
library(data.table) #%like%
```

#2. Powtarzalność wyników przy każdym uruchomieniu raportu na tych samych danych

``` {r powtarzalnosc}

set.seed(23)
```

#3.Wczytanie danych z pliku

Wczytujemy dane z pliku all_summary.csv. 
Za pomocą heurystyki wyznaczamy klasy pierwszych 100 wierszy.

```{r dane, results='hide', cache=TRUE}

filePath = "C:/Users/micha/Downloads/all_summary.csv"
initial <- read.table(filePath, nrows = 100, sep = ";", header = TRUE)
classes <- sapply(initial, class)
file_data <- read.table(filePath, colClasses = classes, sep = ";", na.strings = 'nan', nrows = 10000, header = TRUE)
data <- file_data
```

Dane znajdują się w zmiennej data.



#4.Wstępne czyszczenie danych:

Liczba wierszy w zbiorze: `r nrow(data)`.

Usuwamy wiersze posiadające wartość zmiennej ref_name równą: “UNK”, “UNX”, “UNL”, “DUM”, “N”, “BLOB”, “ALA”, “ARG”, “ASN”, “ASP”, “CYS”, “GLN”, “GLU”, “GLY”, “HIS”, “ILE”, “LEU”, “LYS”, “MET”, “MSE”, “PHE”, “PRO”, “SEC”, “SER”, “THR”, “TRP”, “TYR”, “VAL”, “DA”, “DG”, “DT”, “DC”, “DU”, “A”, “G”, “T”, “C”, “U”, “HOH”, “H20”, “WAT”

```{r wiersze}
res_names_to_remove <- c('UNK', 'UNX', 'UNL', 'DUM', 'N', 'BLOB', 'ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLN', 'GLU', 'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'MSE', 'PHE', 'PRO', 'SEC', 'SER', 'THR', 'TRP', 'TYR', 'VAL', 'DA', 'DG', 'DT', 'DC', 'DU', 'A', 'G', 'T', 'C', 'U', 'HOH', 'H20', 'WAT')
data <- filter(data, !res_name %in% res_names_to_remove)
```

Liczba wierszy w zbiorze po usunięciu wierszy z ww. wartościami res_name: `r nrow(data)`.



#5. Analiza brakujących danych:

W poniższej sekcji oczyścimy dane z kolumn i wierszy zawierających wartości NaN.

Na początku analiza kolumn. 

Wyznaczamy kolumny, które zawierają przynajmniej jedną wartość NaN, grupujemy po nazwie.

```{r brakujace_dane, cache=TRUE, warning=FALSE, message=FALSE }

column_value_DT <- gather(data, "column_name", "val", 1:ncol(data))
columns_with_nans <- filter(column_value_DT, is.na(column_value_DT$val))[,1]

```

Wyświetlamy podsumowanie:

```{r brakujace_dane2}

table(columns_with_nans)
```

Jak widać na podsumowaniu powyżej, dla wszystkich wierszy kolumna weight_col ma wartość NaN.
Usuwamy ją ze zbioru danych:

``` {r usun_weight_col}
data <- data[,-which(names(data) == 'weight_col' )]
```

Widać również, że część wierszy nie posiada wartości dla kolumn zaczynających się od part_02 oraz part_01. 

W celu oczyszczenia danych usuwamy te wiersze.

``` {r usuniecie_wierszy_z_nan}

    all_rows_count <- nrow(data)
    data <- data[complete.cases(data),]
    cleaned_rows_count <- nrow(data)
    removed_rows_count <- all_rows_count - cleaned_rows_count 
```

Usunięto `r removed_rows_count` wierszy. Stanowi to `r removed_rows_count*100/all_rows_count ` % wszystkich wierszy.



#6. Podsumowanie danych:

Liczba wierszy: `r nrow(data)` 

Liczba kolumn: `r ncol(data)`

Liczba unikalnych wartości res_name: `r length(unique(data$res_name))`

Poniżej rozmiar data frame w pamięci (w Mb):

``` {r size}
print(object.size(data), units='Mb')
```



#7. Ograniczenie liczby klas do 50 najpopularniejszych wartości

W tej sekcji filtrujemy dane do wierszy, których klasa znajduje się wśród 50 najpopularniejszych.

Na początku grupujemy dane po atrybucie res_name i sortujemy.


```{r ograniczenie1}
top50 <- sort(table(data$res_name), decreasing=TRUE)[1:50]
top50names <- names(top50)


```

Poniżej znajduje się posortowana lista 50 najpopularniejszych klas.

```{r ograniczenie2}
top50names
```


Filtrujemy za pomocą wyznaczonych 50 nazw

```{r ograniczenie3}
data <- filter(data, res_name %in% top50names)
data$res_name <- droplevels(data$res_name)
```


Pozostało `r nrow(data)` wierszy.


#8.Korelacja między zmiennymi:
```{r brakujace_dane1}

```

#9. Ile przykładów ma każda klasa
```{r ile_przykladow}
sort(table(data$res_name), decreasing=TRUE)

```

#10.Wykresy:

```{r wykres1}

chart_data_1 <- ggplot(data, aes(x = data$local_res_atom_non_h_count))
chart_layout_1 <- geom_histogram(col = 'blue', fill = 'orange', binwidth = 1)
chart1 <- chart_data_1 + chart_layout_1 + labs(title="Rozkład liczby atomów") + labs(x="Liczba atomów")
chart1

```

```{r wykres2}

chart_data_2 <- ggplot(data, aes(x = data$local_res_atom_non_h_electron_sum))
#chart_layout_2 <- geom_histogram(col = 'blue', fill = 'orange', binwidth = 5)
chart2 <- chart_data_2 + chart_layout_1 + labs(title="Rozkład liczby elektonów") + labs(x="Liczba elektronów")
chart2
```


#11. Analiza klas pod względem niezgodności liczby atomów i elektronów
```{r niezgodnosc}

atoms_incompatibility <- unique(select(data, res_name, local_res_atom_non_h_count, dict_atom_non_h_count))

```

Dodajemy kolumnę z różnicą

```{r niezgodnosc2}

atoms_incompatibility_with_diff <- mutate(atoms_incompatibility, diff = abs(local_res_atom_non_h_count - dict_atom_non_h_count))

```

Sortujemy

```{r niezgodnosc3}

atoms_incompatibility_with_diff_sorted <- atoms_incompatibility_with_diff[order(-atoms_incompatibility_with_diff$diff),]
head(atoms_incompatibility_with_diff_sorted, 5)

```

Tabela pokazująca 10 klas z największą niezgodnością liczby atomów:

```{r niezgodnosc4}

atoms_table_data <- select(atoms_incompatibility_with_diff_sorted, res_name, diff)[1:10,]
row.names(atoms_table_data) <- NULL
atoms_table_data %>% knitr::kable(col.names = c('res_name', 'Niezgodność liczy atomów')) %>% kable_styling()


```


To samo dla elektronów:

```{r niezgodnosc_elektrony}

electrons_incompatibility <- unique(select(data, res_name, local_res_atom_non_h_electron_sum, dict_atom_non_h_electron_sum))

electrons_incompatibility_with_diff <- mutate(electrons_incompatibility, diff = abs(local_res_atom_non_h_electron_sum - dict_atom_non_h_electron_sum))

electrons_incompatibility_with_diff_sorted <- electrons_incompatibility_with_diff[order(-electrons_incompatibility_with_diff$diff),]

electrons_table_data <- select(electrons_incompatibility_with_diff_sorted, res_name, diff)[1:10,]
row.names(electrons_table_data) <- NULL
electrons_table_data %>% knitr::kable(col.names = c('res_name', 'Niezgodność liczy elektronów')) %>% kable_styling()


```




#12. Rozkład wartości kolumn zaczynających się od part_01

```{r fig.height = 90, cache=TRUE}

is_part_01_column <- colnames(data) %like% 'part_01'
part_01_column_names <- colnames(data)[is_part_01_column]
head(part_01_column_names, 10)

filtered_data <- data[is_part_01_column]

gathered_data <- gather(filtered_data, 'col_name', "value", part_01_column_names)
dim(gathered_data)

k <- ggplot(gathered_data, aes(x = gathered_data$value))
i <- k + facet_wrap(vars(gathered_data$col_name), ncol = 3, scales = "free")
i + geom_histogram(bins = 25)

```

#5.Brakujące dane:
```{r brakujace_dane5}

```

#5.Brakujące dane:
```{r brakujace_dane6}

```

#5.Brakujące dane:
```{r brakujace_dane7}

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
